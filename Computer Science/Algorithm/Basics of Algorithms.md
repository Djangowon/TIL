# Basics of Algorithms
## 알고리즘 정의
* 주어진 문제를 풀기 위한 명령어들의 단계적 나열
    * (입출력) 입출력
        * 0개 이상의 외부 입력 -> 1개 이상의 출력
    * (명확성) 각 명령은 모호하지 않고 단순 명확해야 함
    * (유한성) 한정된 수의 단계를 거친 후에는 반드시 종료
    * (유효성) 모든 명령은 컴퓨터에서 수행 가능해야 함
    * (실용적 관점) 효율적이어야 함

> 즉, 주어진 문제에 대한 결과를 생성하기위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 일련의 유한 개의 명령들을 순서적으로 구성한 것

### 알고리즘 생성 단계
> 설계 > 표현/기술 > 정확성 검증 > 효율성 분석

|설계|표현/기술|정확성 검증|효율성 분석|
|:---:|:---:|:---:|:---:|
|상향식 설계</br>하향식 설계|일상 언어</br>순서도</br>의사코드</br>프로그래밍 언어</br>...|수학적 증명|공간 복잡도</br>시간 복잡도|

## 알고리즘의 설계 
### 알고리즘 설계 기법
* 주어지는 문제, 속성, 조건 등이 매우 다양
    * 범용적인 설계 기법은 미존재

* 대표적인 알고리즘 설계 기법
    * 분할정복 divide-and-conquer 방법
    * 동적 프로그래밍 dynamic programming 방법
    * 욕심쟁이 greedy 방법

## 알고리즘 분석
* 정확성 분석
    * 유효한 입력, 유한 시간 -> 정확한 결과 생성 여부?
        * 다양한 수학적 기법으 ㄹ사용해서 이론적인 증명이 필요
* 효율성 분석
    * 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정
    * 메모리 양 -> 공간 복잡도 space complexity
        * 정적 공간 + 동적 공간
    * 수행 시간 -> 시간 복잡도 time complexity

### 시간 복잡도
* 구현한 알고리즘을 컴퓨터에서 실행시켜 실제 수행 시간을 측정하는 것이 아님
    * 이 경우, 일반성 결여
        * 컴퓨터 속도, 프로그래밍 언어, 프로그램 작성 방법, 컴파일러의 효율성 등

* 시간 복잡도 => `알고리즘의 단위 연산의 수행 횟수의 합`
    * 시간 복잡도에 영향을 미치는 요인
        * 입력 크기
            * 입력으로 제공되는 데이터의 크기, 문제가 해결하려는 대상이 되는 개체의 개수
            * ex) 행렬의 크기, 리스트 원소의 수, 그래프의 정점의 수 등
        * 입력 데이터의 상태

### 입력 크기 n이 증가하면 수행 시간도 증가
* 단순히 수행되는 단위 연산의 개수의 합으로 표현하는 것은 부적절함
    * 입력 크기 n에 대한 함수 f(n)으로 표현

### 입력 데이터의 상태에 종속적
* 평균 수행 시간
* 최선 수행 시간
* 최악 수행 시간 -> upper bound 이므로, 이 경우를 알고리즘의 시간 복잡도로 사용한다.

## 점근성능
* 입력 크기 n이 무한대로 커짐에 따라 결정되는 성능

### 점근성능의 결정 방법
* 수행 시간의 다항식 함수에서 `최고차항`만을 계수 없이 취해서 표현
    * 수행 시간의 정확한 값이 아닌 어림 값
        * 수행 시간의 증가 추세를 파악하는데 용이함
            * 알고리즘의 효율성 표현이 용이함

### 점근성능의 표기법
#### `Big-oh` 점근적 상한
* 최악의 수행시간
* f(n) = O(g(n))
#### `Big-omega` 점근적 하한
* 최선의 수행시간
* f(n)=Ω(g(n))
#### `Big-theta` 점근적 상하한
* f(n)=Θ(g(n))

#### 주요 O-표기 간의 연산 시간의 크기 관계
|상수 시간 < 로그 시간 < 선형 시간 < 로그 선형 시간 < 제곱 시간 < 세제곱 시간 < 지수 시간|
|:---:|
|&nbsp;&nbsp;&nbsp;O(1)&nbsp;&nbsp;&nbsp; < &nbsp;&nbsp;&nbsp;O(log n)&nbsp;&nbsp;&nbsp; < &nbsp;&nbsp;&nbsp;O(n)&nbsp;&nbsp;&nbsp; < &nbsp;&nbsp;&nbsp;O(n log n)&nbsp;&nbsp;&nbsp; < &nbsp;&nbsp;&nbsp;O(n²)&nbsp;&nbsp;&nbsp; < &nbsp;&nbsp;&nbsp;O(n³)&nbsp;&nbsp;&nbsp; < &nbsp;&nbsp;&nbsp;O(2ⁿ)&nbsp;&nbsp;&nbsp;|

#### 알고리즘의 시간 복잡도 구하기
* 알고리즘의 시간 복잡도를 구하려면
    * 알고리즘의 수행 시간 f(n)을 구한 후, 
    * f(n)=O(g(n))을 만족하는 최소 차수의 함수 g(n)을 찾음

* 실용적인 접근 방법
    * 알고리즘에 나타난 루프의 반복횟수를 조사하여 시간 복잡도를 취함

## 순환 알고리즘의 성능
* 순환 recursion, 재귀
    * 알고리즘의 수행 과정에서 자기 자신의 알고리즘을 다시 수행하는 형태
        * `T(n) = T(n/2) + O(1), T(1)=c₁` = `Θ(log n)`

### 기본 점화식과 폐쇄형
<img src="https://github.com/Djangowon/TIL/blob/main/image/%E1%84%8C%E1%85%A5%E1%86%B7%E1%84%92%E1%85%AA%E1%84%89%E1%85%B5%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%A8%E1%84%89%E1%85%AB%E1%84%92%E1%85%A7%E1%86%BC.png" height=70% width=70%>
