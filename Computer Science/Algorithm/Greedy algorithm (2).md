# Greedy algorithm
## 최단 경로
* 가중 방향 그래프에서 두 정점을 연결하는 경로 중에서 간선의 가중치의 합이 가장 작은 경로

|플로이드 Floyd 알고리즘|데이크스트라 Dijkstra 알고리즘|
|:---|:---|
|모든 정점 간의 최단 경로|특정한 하나의 정점에서 다른 모든 정점으로의 최단 경로</br>`단일 출발점 최단 경로`|
|동적 프로그래밍 방법 적용|욕심쟁이 방법 적용|
|O(\|V\|³)|O(\|V\|²)|
|가중치의 합이 음수인 사이클이 없다고 가정|음의 가중치를 갖는 간선이 없다고 가정|

## 데이크스트라 알고리즘
* 거리 d[v]
    * 출발점에서 현재까지 선택된 정점 집합 S를 경유하여 정점 v에 이르는 최소 경로의 길이

* 출발점에서 시작하여 거리 d[]가 최소인 정점을 차례로 선택하여 최단 경로를 구하는 방법
    * 초기화 -> 출발점 d[s]=0, 나머지 모든 정점 v의 d[v]=∞, 선택 정점 집합 S={}
    * 미선택 정점 집합 V-S에서 d[]가 가장 작은 정점 u를 선택
        * u의 인접 정점에 대해서 u를 경유하는 거리와 기존 거리 중에서 작은 것을 새로운 거리값으로 조정

* 예제
    > <img src="https://github.com/Djangowon/TIL/blob/main/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-06%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.28.12.png" height=60% width=60%>

* 알고리즘 성능 분석
    > <img src="https://github.com/Djangowon/TIL/blob/main/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-06%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.28.43.png" height=70% width=70%>

* 특징
    * 음의 가중치를 갖는 간선이 없어야 함
        > 즉, 음의 가중치를 갖는 간선이 있으면 데이크스트라 알고리즘 적용 불가
        > > <img src="https://github.com/Djangowon/TIL/blob/main/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-06%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.28.53.png" height=70% width=70%>

## 작업 스케줄링 문제
* 가장 적은 개수의 기계를 사용해서 작업 간의 충돌이 발생하지 않도록 모든 작업을 기계에 할당하는 문제
    * 작업의 집합 T={t₁, t₂, ・・・, t𝗇}, t𝗂 = (s𝗂, f𝗂) (1 ≤ 𝗂 ≤ n)
        * s𝗂: 작업 시작 시간, f𝗂: 작업 완료 시간
    * 작업 간의 충돌이 없어야 함
        * 작업 간의 충돌 -> 한 기계에서 두 개 이상의 작업이 동시에 수행되는 것
        * 작업 𝗂와 𝗃가 충돌을 피하기 위한 조건 -> f𝗂 ≤ s𝗂 또는 f𝗃 ≤ s𝗃
    * 각 작업이 시작되면 중단됨 없이 해당 기계에서 완료되어야 함

* 기본 아이디어
    * 각 단계에서 `시작 시간이 빠른 작업`을 우선적으로 선택해서
        * 충돌이 발생하지 않으면 -> 해당 기계에 배정
        * 충돌이 발생하면 -> 새로운 기계에 배정

* 알고리즘 성능 분석
    > <img src="https://github.com/Djangowon/TIL/blob/main/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-06%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.29.29.png" height=70% width=70%>

## 작업 선택 문제
* 하나의 기계만을 사용해서 충돌 없이 최대 개수의 작업을 기계에 할당하는 문제
    * 작업의 집합 T={t₁, t₂, ・・・, t𝗇}, t𝗂 = (s𝗂, f𝗂) (1 ≤ 𝗂 ≤ n)

* 기본 아이디어
    * 각 단계에서 `완료 시간이 빠른 작업`을 우선적으로 선택해서
        * 충돌이 발생하지 않으면 -> 기계에 배정
        * 충돌이 발생하면 -> 해당 작업을 버림

* 알고리즘 성능 분석
    > <img src="https://github.com/Djangowon/TIL/blob/main/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-06%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.30.27.png" height=70% width=70%>

## 허프만 코딩
* 문자의 빈도 또는 확률 정보를 이용한 통계적 압축 방법
    * 텍스트에서 각 문자가 출현하는 빈도수에 따라 다른 길이의 부호를 부여
        * 출현 빈도수가 높은 문자 -> 짧은 코드
        * 출현 빈도수가 낮은 문자 -> 긴 코드

### 개념과 원리
* 텍스트 `ababcdbad`
    * 8비트 아스키 코드로 표현하는 경우 -> 9문자 x 8비트 = 72비트
    * 고정 길이 변환 코드로 표현하는 경우 -> 9문자 x 2비트 = 18비트
        * 문자 집합 = {a, b, c, d} -> a:00, b:01, c:10, d:11
    * 단순히 빈도수에 따른 가변 길이 변환 코드로 표현하는 경우
        * 빈도수 -> a(3), b(3), c(1), d(2)
            > a -> '0' , b -> '1', c -> '00', d -> '01'
            > > 인코딩하면 010100011001
            > > > but, 다시 디코딩하면 해석이 달리질 여지가 있음 => `디코딩의 모호성 발생`

* 모호성 없이 디코딩하려면 접두부 코드 prefix code 이어야 함
    * 각 문자에 부여된 이진 코드가 다른 문자에 부여된 이진 코드의 접두부가 되지 않는 코드

* 허프만 코딩
    * 접두부 코드, 최적 코드
        * 최적 코드 -> 인코딩된 메시지의 길이가 가장 짧은 코드
    * 인코딩 과정
        > (1) 주어진 텍스트에서 각문자의 출현 빈도수를 계산  
        > (2) 각 문자의 빈도수를 이용하여 `허프만 트리`를 생성하여 각 문자에 이진 코드를 부여  
        > (3) 주어진 텍스트의 각 문자를 이진 코드로 변환하여 압축된 텍스트를 생성

## 허프만 트리
* 허프만 코딩에서 각 문자에 이진 코드를 부여하기 위해서 상향식으로 만드는 이진 트리
    * 욕심쟁이 방법 적용
    * 리프 노드가 각 문자를 표시하는 전 이진트리
* 각 문자가 개별적인 트리인 상태에서 시작해서 빈도수가 작은 두 트리를 합쳐서 보다 큰 트리를 생성하는 과정을 반복
    * 각 노드는 빈도수로 표시
    * 좌우의 두 간선은 각각 0과 1로 레이블됨
    * 합쳐지는 두 트리를 자식 노드로 갖는 부모 노드를 생성
        * 부모 노드의 빈도수는 두 자식 노드의 빈도수의 합으로 표시

* 허프만 트리는 유일하지 않음
    > 즉, 합쳐지는 방법에 따라 호프만 트리의 모양이 달라지고 각각의 문자에 부여된 이진코드도 다르기 때문에 인코딩된 메세지도 다름
    > > but, 비트 수는 모두 똑같음. 예제로 치면 23비트. 
    > > > 왜냐? 최적 코드이기 때문에 인코딩된 메세지의 길이는 가장 짧은 길이가 된다.

* 디코딩 과정
    * 압축된 스트링을 처음부터 차례대로 읽으면서 주어진 접두부 코드와 일치하는 코드가 나오면 해당 문자로 변환

* 알고리즘 성능 분석
    > <img src="https://github.com/Djangowon/TIL/blob/main/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-06%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.31.08.png" height=70% width=70%>

* 특징
    * 각 문자의 빈도수를 모르는 경우
        * 주어진 텍스트를 2번 읽음
            > (1) 각 문자의 빈도수를 계산할 때  
            > (2) 텍스트를 읽으면서 실제 인코딩할 때  
            > > 이 경우 속도가 상당히 느려 실용성이 없음
    * 압축된 데이터를 디코딩하려면
        * 각 문자의 빈도수, 허프만 트리에 대한 정보, 문자 집합 정보가 필요
            * 압축된 데이터의 헤더로써 필요한 정보를 제공 -> 실제 압축률 저하를 초래
