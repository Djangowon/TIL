# Big O notation

## Big O란?
* 알고리즘의 스피드 표현법
* 알고리즘 스피드는 완료까지 걸리는 스텝(절차)의 수로 결정됨
* Big O를 사용하면 시간복잡도를 빠르게 설명할 수 있다, 읽기 쉽고 바로 설명이 가능함
* Big O를 이해하면 알고리즘 분석을 빠르게 할 수 있고 언제 무엇을 쓸지 빠르게 파악이 가능함
* 내 자신의 코드를 평가할 수도 있다. (미래에 어떻게 작동할지 알 수 있으므로)  
따라서 같은 작업을 수행하는데 5번의 스텝만 필요한 알고리즘이 10개 스텝이 필요한 알고리즘보다 훌륭한 알고리즘 일 것이다.

## Constant Time (상수 시간) / O(1)
만약 어떤 알고리즘의 T(n) 값이 입력 크기에 구애받지 않는 값에 의해서 한정된다면, 이 알고리즘은 상수 시간(O(1) 시간이라고 쓰기도 함) 이라고 말할 수 있다.
* 인풋 사이즈와 관계없이 스텝이 정해진 알고리즘들
* 항상 선호되는 알고리즘이다.
```python
def print_first(arr):
    print(arr[0])
```
위와 같은 배열을 인풋으로 사용할 함수가 있을 때, 이건 배열의 첫번째 element를 프린트 할 것이다.  
이 함수는 인풋이 얼마나 크든 말든 관계없이 동일한 수의 스텝이 필요하다. 이 함수의 시간복잡도는 Constant Time이다.  
n이 얼마나 크든 관계없이 상수에 신경을 쓰지 않는다. -> 여전히 constant time (일정한 상수/시간) 이므로.  

```python
def print_first(arr):
    print(arr[0])
    print(arr[0])
```
위와 같이 프린트를 두번한다 하더라도 O(1)이다.  
Big O는 함수의 디테일엔 관심이 없고 Big O는 러프하게 어떻게 이 함수가 작동하는지, 큰 원리에만 관심이 있다.  
인풋 사이즈가 엄청나게 커져도 관계없이 미리 정해진 숫자에 따라 작동한다.

## Linear Time (선형 시간) / O(N)
만약 시간복잡도가 O(n)이면, 이 알고리즘은 O(n)시간 혹은 선형 시간을 갖는다고 말할 수 있다. 약식으로 충분히 큰 입력 크기에 대해서 수행시간이 입력 크기에 따라 선형적으로 증가함을 의미한다.
```python
def print_all(arr):
    for n in arr:
        print(n)
```
위와 같은 각 아이템을 다 프린트하는 함수가 있을 때, 배열 사이즈가 10이라면 10번 프린트를 한다.  
만약 배열이 100개라면 100개 스텝이로 이어진다. 선형 검색이랑 비슷하며, 배열이 커지면 필요 스텝도 커진다.
```python
def print_all(arr):
    for n in arr:
        print(n)
    for n in arr:
        print(n)
```
예를 들어 함수를 반복한다거나 하면 이론적으로는 이게 O(2N)이 되어야 하지만 2가 상수이기 때문에 버리고 여전히 O(N)이라고 표현한다.  
이유는 `인풋이 증가하면 스텝도 증가한다는 핵심 메시지만 전달하기 때문`  
* 상수는 관계없음
* 인풋이 증가하면 스텝도 증가한다
* 혹은 선형 시간복잡도를 그래프로 표현하면 대각선으로 보임

## Quadratic Time (이차 시간) / O(N^2)
* Quadratic Time은 Nested Loops (중첩 반복)이 있을 때 발생함
```python
def print_twice(arr):
    for n in arr:
        for x in arr:
            print(x, n)
```
위와 같은 배열의 각 아이템에 대하여 루프를 반복하여 실행하는 함수가 있을 떄, 시간복잡도는 인풋의 n^2 이다.  
인풋이 10개라면 완성하는데 100개의 스텝이 필요하다. -> 루프 안의 루프에서 함수를 실행하므로 * 20개의 데이터는 400개 스텝  
따라서 이차 시간과 비교하면 선형 시간복잡도가 더 효율적인 것으로 선호될 것이다.

## Logarithmic Time (로그 시간) / O(log n)
만약 T(n) = O(log n) 이라면, 이 알고리즘은 로그 시간이 걸린다고 말할 수 있다. 
* 이진검색 알고리즘 설명할 때 씀
* 이진검색에서는 인풋 사이즈가 더블이 되어도 스텝은 딱 +1 밖에 증가를 안 함 
    * 이진검색에서는 각 프로세스의 스텝을 절반으로 나눠서 진행하기 때문
* 로그(logarithm)는 지수(exponent)의 정 반대임
```
2^5 = 32
```
** 로그는 이것의 정 반대  
예를 들어, 32를 2로 몇번을 나눠야 1이 나올까 (5번) 같은 느낌

이진 검색에서는 인풋을 일단 반으로 나누고 시작한다. -> 매번 스텝을 진행할 때 마다
그렇기 때문에 인풋이 2배로 커져도 검색을 하기위한 스텝은 +1만 증가
* 왜냐면 한번만 더 나누면 되는 것이니까

* 선형 시간보다는 빠르고 상수 시간보다는 느리다.
* 이진 검색은 정렬되지 않은 배열엔 사용할 수 없다.  
    => 빅오 표기법은 시간 복잡도 외에도 공간 복잡도를 표현하는데 널리 쓰이는데, 알고리즘은 `시간과 공간이 트레이드 오프 관계이다` (트레이드 오프 : 하나가 증가하면 다른 하나는 감소한다.)
