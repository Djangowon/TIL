# Memory management
## 프로세스와 메모리
* 프로세스의 동작
    * 프로그램 카운터를 참조하여 메모리로부터 수행될 명령을 읽어 CPU의 해당 명령을 수행

### 기억장치 계층구조
* 적절한 비용으로 높은 성능을 낼 수 있도록 계층적으로 구성
    > CPU, `레지스터`
    > > 캐시 기억장치
    > > > 메모리
    > > > > 보조기억장치

    * 위로 갈 수록 접근속도가 빠르고, 비트당 기억장치 비용이 높음

### 메모리 관리
#### 운영체제가 고민해야 될 부분
* 메모리 호출
    * 언제 새로운 프로세스를 메모리에 둘 것인가?
* 메모리 배치
    * 실행될 프로세스를 메모리 내의 어느 곳에 둘 것인가?
* 메모리 교체
    * 메모리가 꽉 찬 상태에서 새로운 프로세스를 적재해야 한다면 어떤 프로세스를 제거할 것인가?
* 그 외
    * 메모리를 고정 분할할 것인가 동적 분할할 것인가?
    * 프로세스의 적재 영역이 고정적인가 유동적인가?

## 단일 프로그래밍 환경
* 초기의 시스템
    * 오직 하나의 프로세스만 메모리를 전용으로 사용
    * 프로세스는 하나의 연속된 블록으로 메모리에 할당(연속 메모리 할당)

* 문제점
    * 메모리 용량을 초과하는 프로세스는 실행 불가
    * 메모리 낭비
        * 당장 사용되지 않는 프로세스의 영역도 계속 적재
    * 자원의 낭비
        > 계산 위주의 사용자 프로그램을 사용할 경우나 입출력 위주의 사용자 프로그램을 사용하는 경우, 하나의 프로세스만 돌리다보니까 입출력을 받을 때 CPU가 놀고 있거나, CPU를 사용하는 동안 입출력 장치는 놀고있 는 자원이 낭비되는 상태

## 다중 프로그래밍 환경
* 다중 프로그래밍(멀티프로그래밍)
    * 여러 개의 프로세스가 메모리에 동시에 적재되는 것
    * CPU 연산과 입출력을 동시에 함으로써 CPU 이용도와 시스템 처리량 증가

### 메모리 분할
* 여러 프로세스를 메모리에 적재하기 위하여 고안된 방법
* 하나의 분할에 하나의 프로세스가 적재
* 두 가지 방식: 고정 분할, 동적 분할

### 고정 분할
* 메모리를 여러 개의 고정된 크기의 영역으로 분할
* 프로세스 배치 방법1
    * 분할 영역마다 큐를 두고 큐에 들어온 프로세스는 해당 분할 영역에만 적재
    * 절대 번역 및 적재
    * 효율성 낮음
<img src="https://github.com/Djangowon/TIL/blob/main/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%209.09.47.png" height=60% width=60%>

* 프로세스 배치 방법2
    * 하나의 큐만 두고 큐에 들어온 프로세스는 어느 분할 영역에든 적재
    * 재배치 가능 번역 및 적재
    * 복잡함
<img src="https://github.com/Djangowon/TIL/blob/main/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%209.09.56.png" height=60% width=60%>

* 문제점: 내부 단편화
    * 프로세스의 크기가 적재된 분할 영역의 크기보다 작아서 분할 영역 내에 남게 되는 메모리는 낭비됨 
        * 프로세스의 크기를 미리 알고 그에 맞춰 고정 분할을 해야함
        * 현실적이지 못함

### 동적 분할
* 메모리의 분할 경계가 고정되지 않음
* 각 프로세스에게 필요한 만큼의 메모리만을 할당

* 문제점: 외부 단편화
    * 메모리의 할당과 반환이 반복됨에 따라 작은 크기의 공백이 메모리 공간에 흩어져 생김
    * 외부 단편화 해결 방법
        * `통합`
            * 인접된 공백을 더 큰 하나의 공백으로 만듦
                * 통합이 되어도 여전히 여러 공백이 메모리 내에서 여기저기 분산되어 있을 수 있음
        * `집약`
            * 메모리 내의 모든 공백을 하나로 모음

### 메모리 보호
* 여러 프로세스가 동시에 메모리에 상주하므로 프로세스가 다른 할당영역을 침범하지 않게 하는 것
* CPU의 하한 레지스터, 상한 레지스터

## 메모리 배치기법
* 새로 반입된 프로그램이나 데이터를 메모리의 어느 위치에 배치할 것인가를 결정
* 종류: 최초 적합, 후속 적합, 최적 적합, 최악 적합

### 최초 적합
* 프로세스가 적재될 수 있는 빈 공간 중에서 가장 먼저 발견되는 곳을 할당

<img src="https://github.com/Djangowon/TIL/blob/main/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%209.34.05.png" height=80% width=80%>

### 후속 적합
* 최초 적합의 변형으로 이전에 탐색이 끝난 그 다음 부분부터 시작

<img src="https://github.com/Djangowon/TIL/blob/main/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%209.34.37.png" height=80% width=80%>

### 최적 적합
* 필요한 공간을 제공할 수 있는 빈 공간 중에서 가장 작은 곳을 선택하여 할당

<img src="https://github.com/Djangowon/TIL/blob/main/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%209.34.56.png" height=80% width=80%>

### 최악 적합
* 필요한 공간을 제공할 수 있는 빈 공간 중에서 가장 큰 곳을 선택하여 할당

<img src="https://github.com/Djangowon/TIL/blob/main/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%209.35.25.png" height=80% width=80%>


## 정리
* 프로세스가 실행되기 위해서는 수행될 명령이 메모리상에 존재해야 한다.
* 컴퓨터 시스템의 기억장치는 적은 비용으로 높은 성능을 제공하기 위해 계층적으로 구성된다.
* 단일 프로그래밍 환경에서의 연속 메모리 할당기법은 관리기법이 단순하지만, 컴퓨터 자원을 효율적으로 사용하는 데 문제가 있다.
* 다중 프로그래밍을 통해 CPU와 주변장치의 이용률을 높일 수 있다.
* 고정 분할 방식은 정해진 크기의 분할 영역으로 메모리를 활용하는 방식으로 각 분할 영역에서 내부 단편화가 발생할 수 있다.
* 동적 분할 방식은 각각의 작업에 필요한 만큼의 메모리를 할당함으로써 내부 단편화를 제거하지만 외부 단편화가 발생할 수 있다.
* 외부 단편화는 통합과 집약기법으로 해결 가능하다.
* 메모리 배치기법은 프로세스를 메모리의 어디에 배치할 것인가 하는 결정과 관련되어 있으며, 최초 적합, 후속 적합, 최적 적합, 최악 적합 기법이 있다.
