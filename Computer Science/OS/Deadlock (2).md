# Deadlock
## 교착상태 회피
* 프로세스의 자원 사용에 대한 사전 정보를 활용하여 교착상태가 발생하지 않는 상태에 머물도록 하는 방법
    * 사전 정보: 현재 할당된 자원, 가용상태의 자원, 프로세스들의 최대 요구량

* 프로세스의 상태 영역
    * 안전상태
        * 안전 순서열이 존재
        * 교착상태를 회피하면서 각 프로세스에게 그들의 최대 요구량까지 빠짐없이 자원을 할당할 수 있는 상태
            > 안전상태라면 교착상태가 일어나지 않음
    * 불안전상태
        * 안전 순서열이 존재하지 않음
        * 교착상태가 될 가능성이 있음
            > 즉, 불안전상태 ≠ 교착상태

### 안전 순서열
* 순서 있는 프로세스의 집합 <p₁,p₂,・・・,p𝗇>
* 각 p𝗂에 대해, p𝗂가 추가로 요구할 수 있는 자원 소요량이 현재 가용 상태이거나 혹은 현재 가용인 자원에 p𝗃(단, 𝗃 < 𝗂)에 할당된 자원까지 포함하여 할당 가능한 경우

* 교착상태는 불안전상태에서 발생
    * 불안전상태: 할당 과정에 따라 교착상태가 될 수도 있는 상태

* 프로세스가 가용상태의 자원을 요구하더라도 안전상태를 유지하기 위해 프로세스는 대기상태가 될 수 있음

## 교착상태 회피 알고리즘
### 각 자원 유형의 단위자원이 여러 개일 경우
* 은행원 알고리즘
    * 자원을 요청받으면 그 자원을 할당해 주고 난 후의 상태를 계산해서 그것이 안전상태가 보장되는 경우에만 자원을 할당

### 은행원 알고리즘
```
① REQ𝗂 ≤ NEED𝗂 가 거짓이면 오류  
② REQ𝗂 ≤ AVAIL 이 거짓이면 p𝗂는 대기  
③ REQ𝗂 ≤ AVAIL 이면  
    ③-1 다음과 같이 할당 후와 같은 상태를 만듦  
        AVAIL 🡠 AVAIL - REQ𝗂  
        ALLOC𝗂 🡠 ALLOC𝗂 + REQ𝗂  
        NEED𝗂 🡠 NEED𝗂 - REQ𝗂  
    ③-2 이 상태가 `안전상태인지를 조사`  
    ③-3 안전상태이면 REQ𝗂 를 할당  
    ③-4 그렇지 않으면 프로세스를 대기상태로, 데이터 구조는 이전 상태로 복구  
```    

### 안전 알고리즘 (`안전상태인지를 조사`)
```
① 길이가 각각 𝗆,𝗇인 WORK와 FINISH 초기화
    WORK 🡠 AVAIL
    FINISH(𝗂) 🡠 false, 𝗂=1,2,・・・,𝗇
② FINISH(𝗂) = false이고 NEED𝗂 ≤ WORK 인 𝗂 찾기
    그런 𝗂 가 없으면 go to ④
③ WORK 🡠 WORK + ALLOC𝗂
    FINISH(𝗂) 🡠 true
    go to ②
④ 모든 𝗂에 대하여 FINISH(𝗂) = true 이면 안전상태
```
* 시간 복잡도: O(𝗆𝗇²)

### 각 자원 유형의 단위자원이 하나밖에 없는 경우
* 변형된 자원할당 그래프
    * 자원을 요청받으면 그 요구간선을 할당간선으로 변환하여도 사이클이 발생되지 않는 경우에만 자원을 할당
        * 할당간선(r𝗃,p𝗂): 자원r𝗃가 프로세스p𝗂에 할당됨
        * 요구간선(p𝗂,r𝗃): 프로세스p𝗂가 자원r𝗃를 요구함
        * 선언간선(p𝗂,r𝗃): 앞으로 프로세스p𝗂가 자원r𝗃를 요구하게 될 것임

## 교착상태 탐지 및 복구
* 교착상태 탐지
    * 시스템의 교착상태 여부를 탐지하기 위해 주기적으로 상태 조사 알고리즘을 수행

* 교착상태 복구
    * 교착상태가 탐지된 경우 복구조치에 들어감

### 교착상태 탐지
* Shoshani와 Coffman 알고리즘
    * 현 시점에 필요한 요구상태만 체크함
    * NEED 대신에 REQ만 사용

```
① 길이가 각각 𝗆,𝗇인 WORK와 FINISH 초기화
    WORK 🡠 AVAIL
    ALLOC𝗂 ≠ 0 이면 FINISH(𝗂) 🡠 false
    그렇지 않으면 FINISH(𝗂) 🡠 true, 𝗂=1,2,・・・,𝗇
② FINISH(𝗂) = false이고 REQ𝗂 ≤ WORK 인 𝗂 찾기
    그런 𝗂 가 없으면 go to ④
③ WORK 🡠 WORK + ALLOC𝗂
    FINISH(𝗂) 🡠 true
    go to ②
④ 어떤 𝗂에 대하여 FINISH(𝗂) = false 이면 교착상태
```
* 시간 복잡도: O(𝗆𝗇²)
* 탐지 알고리즘 수행 시점
    * 즉시 받아들일 수 없는 할당요구가 있을 때
    * 정해진 시간간격 또는 CPU 효율이 일정 수준 이하로 떨어질 때

### 교착상태 복구
* 복구의 주체
    * 오퍼레이터: 교착상태 발생을 알려주면 수작업으로 복구
    * 시스템: 자동적으로 복구

* 복구의 방법
    * 교착상태 프로세스를 종료
        * 모든 교착상태 프로세스를 종료
            * 단점: 그동안 진행했던 내용들에 대한 복원 비용이 큼
        * 사이클이 제거될 때까지 프로세스를 하나씩 종료
            * 단점: 종료 대상을 선택하기위한 비용, 매번 교착상태 재확인을 위한 비용

    * 교착상태 프로세스로부터 자원을 회수
        * 사이클이 제거될 때까지 자원을 단계적으로 선점하여 다른 프로세스들에 할당
        * 고려사항: 희생자 선택, 복귀, 기아상태

## 복합적 접근방법
* 방지, 회피, 탐지 및 복구를 복합적으로 사용
    * 자원을 유형에 따라 계층적으로 분류
    * 각 계층에 대하여 자원순서를 부여
    * 각 계층별로 방지, 회피, 탐지 및 복구 중 적절한 방법을 적용

## 정리
* 교착상태를 처리하는 방법은 교착상태를 방지하는 방법, 교착상태를 회피하는 방법, 교착상태를 탐지하여 이를 복구하는 방법 등이 있다.
* 교착상태 회피 방법은 프로세스의 자원 사용에 대한 사전 정보를 활용하여 교착상태가 발생할 수 있는 불안전상태가 되는 것을 피한다.
* 은행원 알고리즘은 프로세스가 요구한 자원을 할당해 줄 경우 안전 순서열이 존재하는지를 검사하여 요구 수용 여부를 결정한다.
* 변형된 자원할당 그래프에서 선언간선을 할당간선으로 바꾸어도 사이클이 발생하지 않는 안전상태일 경우 자원 요청을 수용한다.
* 교착상태 탐지 및 복구 방법은 교착상태가 발생하였는가를 탐지한 후, 희생자를 선택하여 프로세스를 중지시키거나 자원을 선점한다.
