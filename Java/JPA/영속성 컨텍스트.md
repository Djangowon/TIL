# 영속성 컨텍스트

<br>
<br>

### JPA에서 가장 중요한 2가지
- 객체와 관계형 데이터베이스 매핑하기
- 영속성 컨텍스트
	- JPA를 이해하는데 가장 중요한 용어임
	- "엔티티를 영구 저장하는 환경"이라는 뜻
	- `EntityManager.persist(entity);`
	- 영속성 컨텍스트는 논리적인 개념임
	- 눈에 보이지 않음
	- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근함

<br>

### 엔티티 매니저 팩토리?
> 웹 어플리케이션 개발을 한다고 할 때, 엔티티 매니저 팩토리를 통해 고객의 요청이 올 때마다 엔티티 매니저를 생성함 -> 엔티티 매니저는 내부적으로 데이터베이스 커넥션을 사용해서 DB를 사용함


<br>
<br>

## 엔티티의 생명주기
* 비영속(new/transient)
	* 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
	* 예를 들면, 객체를 생성한 상태는 JPA와 관계없이 생성만 한 상태이기 때문에 비영속 상태임
* 영속(managed)
	* 영속성 컨텍스트에 관리되는 상태
	* 객체를 생성한 다음에 엔티티 매니저를 얻어와서 엔티티 매니저에 persist() 해서 객체를 집어넣었을 때, 엔티티 매니저 안에 있는 영속성 컨텍스트에 객체가 들어가면서 영속 상태가 됨
	```java
	em.persist(member);
	```
* 준영속(detached)
	* 영속성 컨텍스트에 저장되었다가 분리된 상태
	```java
	em.detach(member);
	```
* 삭제(removed)
	* 삭제된 상태
	* 실제 DB 삭제를 요청하는 상태
	```java
	em.remove(member);
	```

<br>

영속상태가 된다고 해서 바로 DB에 쿼리가 날라가지 않음 => 트랜잭션을 커밋하는 시점

<br>
<br>

## 영속성 컨텍스트이 이점
- 1차 캐시
- 동일성(identity) 보장
- 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
- 변경 감지(Dirty Checking)
- 지연 로딩(Lazy Loading)

<br>
<br>


## 1차 캐시
1차 캐시를 영속성 컨텍스트로 이해해도 됨.
```java
Member member = new Member();
member.setId("member1");
member.setUswername("회원1");

// 1차 캐시에 저장됨
em.persist(member);

// 1차 캐시에서 조회
Member findMember = em.find(Member.class, 'member1');
```

<br>

### 영속성 컨텍스트에 데이터가 없는 경우?
> 1차 캐시에 없음 -> DB 조회 -> 1차 캐시에 저장 -> 반환

<br>

고객의 요청이 하나 들어와서 비즈니스가 끝나버리면 영속성 컨텍스트를 지운다는 점(1차 캐시도 다 날라감)을 알아야 한다.  
굉장히 짧은 찰나의 순간에서만 이득이 있다.  
1차 캐시는 데이터베이스 한 트랜잭션 안에서만 효과가 있기 때문에 성능의 이점을 크게 얻을 수 있는 장점은 없다.


<br>
<br>

## 영속 엔티티의 동일성 보장
- 자바 컬렉션에서 똑같은 레퍼런스의 객체를 꺼냈을 때 == 연산자로 비교해보면 true 반환되는 것처럼 동일성을 보장함
- 1차 캐시로 반복가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공함

<br>


> JPA 기본적으로 내부에서 리플렉션같은 걸 쓰기 때문에 동적으로 객체를 생성해내야 함
그래서 기본생성자가 있어야 한다.


<br>
<br>


## 엔티티 등록 - 트랜잭션을 지원하는 쓰기 지연
- 엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야 함
- 트랜잭션 내부의 SQL을 데이터베이스에 바로 바로 보내지 않고 모아둠(쓰기 지연 SQL 저장소에)
- 트랜잭션 커밋을 하는 순간 데이터베이스에 쓰기 지연 SQL 저장소에 모아둔 SQL을 한번에 보냄(flush), 이 후 실제 데이터베이스 트랜잭션이 커밋됨
- 쓰기 지연 SQL 저장소의 쿼리를 트랜잭션 커밋했을 때 설정한 value만큼 한번에 모아서 보내는 옵션
  > `<property name="hibernate.jdbc.batch_size" value="10"/>`


<br>
<br>


## 엔티티 수정 - 변경 감지
- Dirty Checking: JPA의 변경감지 기능이 제공됨
- 커밋하는 시점에 내부적으로 flush()가 호출됨 -> 엔티티와 스냅샷을 비교 -> 값이 바뀌었을 경우 SQL을 쓰기 지연 저장소에 만들어둠 -> 데이터베이스에 한번에 보냄(flush) -> commit
> 값을 읽어온 최초 시점의 상태를 스냅샷을 떠둠.


<br>
<br>


## 엔티티 삭제
- 수정 메커니즘과 동일함
- 트랜잭션 커밋 시점에 delete 쿼리가 나감
```java
// 삭제 대상 엔티티 조회
Member memberA = em.find(Member.class, "memberA");

em.remove(memberA); // 엔티티 삭제
```


<br>
