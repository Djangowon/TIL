# SQL 중심적인 개발의 문제점

<br>
<br>

지금 시대는 객체를 관계형 데이터베이스에 보관하고 관리하는 시대이고, 현재의 애플리케이션 개발을 주로 객체지향 언어인 Java, Scala, Kotlin, C#과 같은 언어를 사용하여 이루어진다.  
애플리케이션 개발 과정에서 가장 빈번하게 발생하는 작업은 CRUD(Create, Read, Update, Delete) 작업.  
객체를 관계형 DB에 보관하려면 수많은 SQL를 사용해야 함.
* 무한 반복되고 지루한 CRUD (자바 객체를 SQL로, SQL을 자바 객체로)
  > insert into  
  > update  
  > select  
  > delete  
* SQL에 의존적인 개발을 피하기 어렵다.


<br>
<br>


## 패러다임의 불일치
객체와 관계형 데이터베이스는 비슷하면서도 굉장히 다르다는 점에서 패러다임의 불일치가 발생한다. 객체지향 프로그래밍은 추상화, 캡슐화, 정보 은닉, 상속, 다형성 등 시스템의 복잡성을 제어할 수 있는 다양한 장치들을 제공한다. 반면 관계형 데이터베이스는 데이터를 테이블 형태로 저장하고, 데이터 간의 관계를 정의하며, SQL 쿼리를 통해 데이터를 조작한다.

<br>

객체를 영구 보관하는 다양한 저장소로는 관계형 데이터베이스 외에도 NoSQL, File, OODB(객체 지향 데이터베이스) 등이 있지만 현실적인 대안으로는 여전히 관계형 데이터베이스가 주로 선택되고 있다.  

#### - 객체를 관계형 데이터베이스에 저장하려면?
  * insert문 일일히 다 만들어주기. SQL 변환 필요.
  * 조회할 경우에도 select문으로 조회한 뒤 객체로 바꿔줘야 함.
  * 개발자의 역할은 객체와 RDB 사이에서 SQL 매퍼 역할을 함.


<br>
<br>


## 객체와 관계형 데이터베이스의 차이
객체와 관계형 데이터베이스 사이의 주요 차이점 중 하나는 상속과 연관관계이다. 관계형 데이터베이스는 기본적으로 객체의 상속 관계를 지원하지 않으며, 객체와 완전히 다른 방식으로 연관관계를 처리한다. 객체는 참조를 사용하여 연관관계를 맺지만, 테이블은 외래 키를 사용하여 JOIN을 통해 연관된 데이터를 가져온다. 이로 인해 객체를 관계형 데이터베이스에 저장할 때 매핑 작업이 복잡해지며, 객체지향 프로그래밍의 장점들을 활용하기 어려워진다.


### 상속
* 관계형 데이터베이스는 기본적으로 객체의 상속 관계가 없다. 비슷한 개념이 있지만, 객체와 완전히 똑같지 않다.
* 관계형 DB의 Table 슈퍼타입 서브타입 관계
  * 부모, 자식같은 테이블을 만들어 데이터를 분리해놓고, 필요할 땐 JOIN해서 가지고 올 수 있다. 부모테이블의 id값을 자식 테이블에서 갖고 있는 형태.
#### - 자바 컬렉션에서 저장, 조회한다고 가정하면?
  * `list.add(album);`  
  * `Album album = list.get(albumId)`; 한줄 컷 (객체에서 객체 세상끼리라서 가능한 것)  
  * `Item item = list.get(albumId);` 부모 타입으로 조회 후 다형성 활용


<br>
<br>

### 연관관계
객체와 관계형 데이터베이스 간의 패러다임 불일치는 연관관계에서도 명확하게 드러난다.
* 객체는 참조를 사용: `member.getTeam()`
* 테이블은 외래 키를 사용: `JOIN ON M.TEAM_ID = T.TEAM_ID`
이러한 패러다임 불일치로 인해 객체지향 프로그래밍을 하면서도 데이터를 관계형 데이터베이스에 저장하려면 객체를 테이블에 맞추어 모델링해야 한다. 그래야 테이블에 맞춘 객체 저장이 가능하므로.
* 객체다운 모델링은 참조로 연관관계를 맺게 됨.
* 객체다운 모델링은 데이터베이스에 저장하기가 굉장히 까다로운데, 예시를 들어보면 아래 코드처럼 번거로운 작업이 필요하다.
```java
SELECT M.*, T.*
  FROM MEMBER M
  JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID;

public Member find(String memberId) {
  // SQL 실행
  Member member = new Member();
  // 데이터베이스에서 조회한 회원 관련 정보를 모두 입력
  Team team = new Team();
  // 데이터베이스에서 조회한 팀 관련 정보를 모두 입력

  // 회원과 팀 관계 설정
  member.setTeam(team);
  return member;
}
```
#### 객체 모델링, 자바 컬렉션에 관리하면?
  * `list.add(member);`
  * `Member member = list.get(memberId);`
  * `Team team = member.getTeam();`

<br>

#### - 객체는 자유롭게 객체 그래프를 탐색할 수 있어야 한다.  
즉, 자바 컬렉션과 같은 객체를 사용하여 객체 모델링을 한다면, 객체 그래프를 자유롭게 탐색하는 것이 가능하고, 연관된 객체를 한 줄의 코드로 간편하게 조회할 수 있다. 하지만 데이터베이스에 객체를 저장하고 조회하기 위해서는 객체와 데이터베이스 간의 패러다임 불일치로 인해 번거로운 변환 작업이 필요하다.

<br>

#### - 데이터베이스에 데이터를 객체로 보관하다보면 처음 실행하는 SQL에 따라 탐색 범위가 결정이 되어버린다. => 엔티티 신뢰 문제 발생.  
계층형 아키텍처는 계층이라는 게 성립하기 위해서 다음 계층을 믿고 쓸 수 있어야 하는데, 레포지토리에 셋팅해둔 쿼리를 까봐야 어떤 데이터까지 가져올 수 있는지 알 수 있게 된다.

<br>

#### - 모든 객체를 미리 로딩할 수는 없다. => 상황에 따라 동일한 회원 조회 메서드를 여러벌 생성해서 써야함.  
객체 모델링을 사용할 경우 모든 객체를 미리 로딩하는 것은 성능상 문제가 발생할 수 있다. 따라서 상황에 따라 여러 버전의 조회 메서드를 생성하여 쿼리를 최적화하는 등의 처리를 해야한다. 또한, 계층형 아키텍처에서의 진정한 의미의 계층 분할이 어려워질 수 있다. (물리적으로는 분할이 되어 있으나 논리적으로는 엮여있다.)

<br>
<br>

### 비교하기 - SQL 사용할 경우
```java
String memberId = '100';
Member member1 = memberDAO.getMember(memberId);
Member member2 = memberDAO.getMember(memberId);
member1 == member2; // 다름
```
실제 데이터는 같지만, 인스턴스가 다름. 다른 인스턴스가 2개 생성된 것.

<br>

### 비교하기 - 자바 컬렉션에서 조회
```java
String memberId = '100';
Member member1 = list.get(memberId)`
Member member2 = list.get(memberId)`
member1 == member2; // 같음 
```
같은 참조, 같은 인스턴스.  

<br>

객체지향적으로 설계를 한다고 하지만, 객체답게 모델링 할수록 매핑 작업만 늘어난다.  
객체를 자바 컬렉션에 저장 하듯이 DB에 저장할 수는 없을까? => `JPA - Java Persistence API`

JPA는 객체지향 프로그래밍과 데이터베이스 간의 매핑을 자동으로 처리하여 객체지향 프로그래밍의 편리함을 유지하면서도 데이터베이스에 객체를 관리할 수 있게 해준다.
따라서 JPA와 같은 ORM 기술을 활용하면 객체를 자바 컬렉션에 저장하듯이 데이터베이스에 저장할 수 있어서 개발자들이 번거로운 매핑 작업 없이도 객체지향 언어를 활용하여 데이터를 관리할 수 있다.
