# Persistence Context

<br>
<br>


## JPA에서 가장 중요한 2가지
* 객체와 관계형 데이터베이스 매핑하기(Object Relational Mappling)
* 영속성 컨텍스트

<br>


----
* 엔티티 매니저 팩토리
	> 웹 어플리케이션 개발을 한다고 할 때, 엔티티 매니저 팩토리를 통해 고객의 요청이 올 때마다 엔티티 매니저를 생성함 -> 엔티티 매니저는 내부적으로 데이터베이스 커넥션을 사용해서 DB를 사용함

<br>
<br>

## 영속성 컨텍스트
* JPA를 이해하는데 가장 중요한 용어
* "엔티티를 영구 저장하는 환경"이라는 뜻
* EntityManager.persist(entity);
	* persist 메서드는 사실 DB에 저장하는 것이 아닌 영속성 컨텍스트에 저장함

<br>

* 영속성 컨텍스트는 논리적인 개념
* 눈에 보이지 않음
* 엔티티 매니저를 통해서 영속성 컨텍스트에 접근함

<br>
<br>

## 엔티티의 생명주기
* 비영속(new/transient)
	* 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
	* 예를 들면, 객체를 생성한 상태는 JPA와 관계없이 생성만 한 상태이기 때문에 비영속 상태임
* 영속(managed)
	* 영속성 컨텍스트에 관리되는 상태
	* 객체를 생성한 다음에 엔티티 매니저를 얻어와서 엔티티 매니저에 persist() 해서 객체를 집어넣었을 때, 엔티티 매니저 안에 있는 영속성 컨텍스트에 객체가 들어가면서 영속 상태가 됨

	```java
	em.persist(member);
	```
   
* 준영속(detached)
	* 영속성 컨텍스트에 저장되었다가 분리된 상태

	```java
	em.detach(member);
	```
    
* 삭제(removed)
	* 삭제된 상태
	* 실제 DB 삭제를 요청하는 상태
	```java
	em.remove(member);
	```

<br>
<br>

> 애플리케이션과 데이터베이스 사이에 굳이 중간 계층으로 두는 영속성 컨텍스트를 왜 사용할까?  
## 영속성 컨텍스트의 이점 
* [1차 캐시](#1차-캐시)
* [동일성(identity) 보장](#영속-엔티티의-동일성-보장)
* [트랜잭션을 지원하는 쓰기 지연(transactional write-behind)](#엔티티-등록---트랜잭션을-지원하는-쓰기-지연)
* [변경 감지(Dirty Checking)](#엔티티-수정---변경-감지)
* 지연 로딩(Lazy Loading)


<br>
<br>

## 1차 캐시
* DB를 먼저 조회하는 것이 아닌 1차 캐시에서 먼저 조회를 함
* DB에는 있고 1차 캐시에 없다면?
	* DB 조회 -> 1차 캐시에 저장 -> 반환 
* 엔티티 매니저는 데이터베이스 트랜잭션 단위로 만들고 데이터베이스 트랜잭션이 끝날 때 같이 종료시킴
	* 즉, 영속성 컨텍스트를 지운다는 것. 1차 캐시 모두 날아감
	* 따라서, 1차 캐시는 데이터베이스 트랜잭션 안에서만 효과가 있기 때문에 성능 이점을 크게 얻을 수 있는 장점은 없음 -> 비즈니스가 정말 복잡할 경우에 쿼리가 조금 줄어드는 정도?

<br>
<br>


## 영속 엔티티의 동일성 보장
* 자바 컬렉션에서 똑같은 레퍼런스의 객체를 꺼냈을 때 == 연산자로 비교해보면 true 반환되는 것처럼 동일성을 보장함
* 1차 캐시로 반복가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공함

<br>
<br>


## 엔티티 등록 - 트랜잭션을 지원하는 쓰기 지연
* 엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야 함
* 트랜잭션 내부의 SQL을 데이터베이스에 바로 바로 보내지 않고 모아둠(쓰기 지연 SQL 저장소에)
* 트랜잭션 커밋을 하는 순간 데이터베이스에 쓰기 지연 SQL 저장소에 모아둔 SQL을 한번에 보냄(flush), 이 후 실제 데이터베이스 트랜잭션이 커밋됨
```java
<property name="hibernate.jdbc.batch_size" value="10"/> //쓰기 지연 SQL 저장소의 쿼리를 트랜잭션 커밋했을 때 한번에 모아서 보내는 옵션
```

<br>


## 엔티티 수정 - 변경 감지
* Dirty Checking: JPA의 변경감지 기능이 제공됨
* 커밋하는 시점에 내부적으로 flush()가 호출됨 -> 엔티티와 스냅샷을 비교 -> 값이 바뀌었을 경우 SQL을 쓰기 지연 저장소에 만들어둠 -> 데이터베이스에 한번에 보냄(flush) -> commit

<br>

## 엔티티 삭제
* 수정 메커니즘과 동일함
* 트랜잭션 커밋 시점에 delete 쿼리가 나감


<br>
<br>


## 플러시
* 영속성 컨텍스트의 변경내용을 데이터 베이스에 반영하는 것임
* 쌓아뒀던 영속성 컨텍스트의 SQL 쿼리들이 데이터베이스에 날려주는 것
* 보통 데이터베이스 트랜잭션이 커밋될 때 플러시가 일어남

<br>

### 플러시가 발생하면 일어나는 것
* 변경 감지
* 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
* 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(INSERT, UPDATE, DELETE 쿼리)

<br>

### 영속성 컨텍스트를 플러시하는 방법
* em.flush() - 직접 호출
* 트랜잭션 커밋 - 플러시 자동 호출
* JPQL 쿼리 실행 - 플러시 자동 호출


<br>
<br>

## Ref
https://www.inflearn.com/course/ORM-JPA-Basic
